// Prisma Schema für Prophezeiung App

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                  String   @id @default(cuid())
  username            String   @unique
  passwordHash        String?
  forcePasswordChange Boolean  @default(false)
  displayName         String?
  avatarUrl           String?
  avatarEffect        String?  // 'glow' | 'particles' | 'lightning' | 'none'
  avatarEffectColors  String?  // JSON-Array: ["cyan", "violet", "teal"]
  role                String   @default("USER")     // UserRole: USER, ADMIN
  status              String   @default("PENDING")  // UserStatus: PENDING, APPROVED, REJECTED, SUSPENDED
  isBot               Boolean  @default(false)      // Künstliche Teilnehmer (Randolf, Kimberly)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  authenticators Authenticator[]
  prophecies     Prophecy[]
  ratings        Rating[]
  auditLogs      AuditLog[]
}

model Authenticator {
  id                   String   @id @default(cuid())
  credentialID         String   @unique
  userId               String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String?
  credentialBackedUp   Boolean  @default(false)
  transports           String?
  name                 String   @default("Mein Passkey")
  createdAt            DateTime @default(now())
  lastUsedAt           DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Round {
  id                  String    @id @default(cuid())
  title               String
  submissionDeadline  DateTime
  ratingDeadline      DateTime
  fulfillmentDate     DateTime
  resultsPublishedAt  DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  prophecies          Prophecy[]
}

model Prophecy {
  id          String    @id @default(cuid())
  title       String
  description String
  creatorId   String
  creator     User      @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  roundId     String
  round       Round     @relation(fields: [roundId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  fulfilled   Boolean?
  resolvedAt  DateTime?

  ratings       Rating[]
  auditLogs     AuditLog[]
}

model Rating {
  id          String   @id @default(cuid())
  value       Int
  prophecyId  String
  prophecy    Prophecy @relation(fields: [prophecyId], references: [id], onDelete: Cascade)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([prophecyId, userId])
  @@index([prophecyId])
  @@index([userId])
}

model AuditLog {
  id          String   @id @default(cuid())
  entityType  String   // "RATING" | "PROPHECY"
  entityId    String   // ID der betroffenen Entität
  action      String   // "CREATE" | "UPDATE" | "DELETE" | "BULK_DELETE"

  prophecyId  String?
  prophecy    Prophecy? @relation(fields: [prophecyId], references: [id], onDelete: SetNull)

  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  oldValue    String?  // JSON-String für vorherige Werte
  newValue    String?  // JSON-String für neue Werte
  context     String?  // z.B. "Prophezeiung wurde bearbeitet - alle Bewertungen zurückgesetzt"

  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([prophecyId])
  @@index([userId])
  @@index([createdAt])
}
